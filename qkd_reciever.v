
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module qkd_reciever(

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HPS //////////
	inout 		          		HPS_CONV_USB_N,
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,
	output		          		HPS_ENET_GTX_CLK,
	inout 		          		HPS_ENET_INT_N,
	output		          		HPS_ENET_MDC,
	inout 		          		HPS_ENET_MDIO,
	input 		          		HPS_ENET_RX_CLK,
	input 		     [3:0]		HPS_ENET_RX_DATA,
	input 		          		HPS_ENET_RX_DV,
	output		     [3:0]		HPS_ENET_TX_DATA,
	output		          		HPS_ENET_TX_EN,
	inout 		          		HPS_GSENSOR_INT,
	inout 		          		HPS_I2C0_SCLK,
	inout 		          		HPS_I2C0_SDAT,
	inout 		          		HPS_I2C1_SCLK,
	inout 		          		HPS_I2C1_SDAT,
	inout 		          		HPS_KEY,
	inout 		          		HPS_LED,
	inout 		          		HPS_LTC_GPIO,
	output		          		HPS_SD_CLK,
	inout 		          		HPS_SD_CMD,
	inout 		     [3:0]		HPS_SD_DATA,
	output		          		HPS_SPIM_CLK,
	input 		          		HPS_SPIM_MISO,
	output		          		HPS_SPIM_MOSI,
	inout 		          		HPS_SPIM_SS,
	input 		          		HPS_UART_RX,
	output		          		HPS_UART_TX,
	input 		          		HPS_USB_CLKOUT,
	inout 		     [7:0]		HPS_USB_DATA,
	input 		          		HPS_USB_DIR,
	input 		          		HPS_USB_NXT,
	output		          		HPS_USB_STP,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		top_GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire hps_reset, counter_reset;

reg [31:0] interrupt_req_reg;

wire tt_we;
wire [13:0] counter_output;
wire [1:0] encoder_output;
reg [15:0] time_tagger_register;
reg [7:0] tt_ram_address;


wire [15:0] tt_ram_output_1;
wire [15:0] tt_ram_output_2;
wire ram_1_be = 0;
wire ram_2_be = 0;
reg ram_1_cs = 0;
reg ram_2_cs = 0;



//=======================================================
//  Structural coding
//=======================================================

soc u0 (
	.clk_clk            (FPGA_CLK1_50),				//    clk.clk
	.reset_reset_n      (hps_reset),       		//  reset.reset_n

	//HPS ddr3
	.memory_mem_a       ( HPS_DDR3_ADDR),     	//  memory.mem_a
	.memory_mem_ba      ( HPS_DDR3_BA),       	// .mem_ba
	.memory_mem_ck      ( HPS_DDR3_CK_P),     	// .mem_ck
	.memory_mem_ck_n    ( HPS_DDR3_CK_N),     	// .mem_ck_n
	.memory_mem_cke     ( HPS_DDR3_CKE),      	// .mem_cke
	.memory_mem_cs_n    ( HPS_DDR3_CS_N),     	// .mem_cs_n
	.memory_mem_ras_n   ( HPS_DDR3_RAS_N),    	// .mem_ras_n
	.memory_mem_cas_n   ( HPS_DDR3_CAS_N),    	// .mem_cas_n
	.memory_mem_we_n    ( HPS_DDR3_WE_N),     	// .mem_we_n
	.memory_mem_reset_n ( HPS_DDR3_RESET_N),  	// .mem_reset_n
	.memory_mem_dq      ( HPS_DDR3_DQ),       	// .mem_dq
	.memory_mem_dqs     ( HPS_DDR3_DQS_P),    	// .mem_dqs
	.memory_mem_dqs_n   ( HPS_DDR3_DQS_N),    	// .mem_dqs_n
	.memory_mem_odt     ( HPS_DDR3_ODT),      	// .mem_odt
	.memory_mem_dm      ( HPS_DDR3_DM),       	// .mem_dm
	.memory_oct_rzqin   ( HPS_DDR3_RZQ),      	// .oct_rzqin    

	// Memory system
	.mem1_s1_address    (tt_ram_address),    	// mem1_s1.address
	.mem1_s1_clken      ('b1),      			//        .clken
	.mem1_s1_chipselect (ram_1_cs), 			//        .chipselect
	.mem1_s1_write      (tt_we),      			//        .write
	.mem1_s1_readdata   (tt_ram_output_1),   	//        .readdata
	.mem1_s1_writedata  (time_tagger_register), //        .writedata
	.mem1_s1_byteenable (ram_1_be), 			//        .byteenable
	.mem2_s1_address    (tt_ram_address),    	// mem2_s1.address
	.mem2_s1_clken      ('b1),      			//        .clken
	.mem2_s1_chipselect (ram_2_cs), 			//        .chipselect
	.mem2_s1_write      (tt_we),      			//        .write
	.mem2_s1_readdata   (tt_ram_output_2),   	//        .readdata
	.mem2_s1_writedata  (time_tagger_register), //        .writedata
	.mem2_s1_byteenable (ram_2_be),  			//        .byteenable
	
	.hps_f2h_irq0_irq   (interrupt_req_reg)    	// hps_f2h_irq0.irq
);

//========================= reciever module =================================
upcounter #(14) counter_1(
	.clk(FPGA_CLK1_50),
	.reset(counter_reset),
	.out(counter_output)
);

reciever_encoding_module encoder_1(
	.clk(FPGA_CLK1_50),
	.ttl_pulses(top_GPIO[3:0]),
	.out(encoder_output),
	.pulse_detected(tt_we)
);

always @(posedge FPGA_CLK1_50 ) begin
	if (tt_we) begin
		tt_ram_address <= tt_ram_address + 1;
		time_tagger_register <= { encoder_output, counter_output };
	end

	// when the tt reg reaches max shift the chip select to the next one
	if (time_tagger_register == 4'hffff) begin
		if (ram_1_cs == 1) begin
			ram_1_cs <= 0;
			ram_2_cs <= 1;
		end else begin
			ram_1_cs <= 1;
			ram_2_cs <= 0;
		end
	end

	// when the tt reg reaches max send an IRQ request to HPS
	if (time_tagger_register == 4'hffff) begin
		if (ram_1_cs == 1) begin
			interrupt_req_reg <= 30;
		end else begin
			interrupt_req_reg <= 32;		
		end
	end
	else begin
		interrupt_req_reg <= 0;
	end
end

//========================= reciever module ends here =================================

assign LED[3:0] = top_GPIO[3:0];

endmodule
